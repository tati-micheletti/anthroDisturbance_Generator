## Everything in this file and any files in the R directory are sourced during `simInit()`;
## all functions and objects are put into the `simList`.
## To use objects, use `sim$xxx` (they are globally available to all modules).
## Functions can be used inside any function that was sourced in this module;
## they are namespaced to the module, just like functions in R packages.
## If exact location is required, functions will be: `sim$.mods$<moduleName>$FunctionName`.
defineModule(sim, list(
  name = "anthroDisturbance_Generator",
  description = paste0("This is a module to generate anthropogenic disturbances.",
                       "It's primarily intended for the Northwest Territories region",
                       " (default), but the structure is universal.",
                       " All needed to do is provide the metadata information ",
                       "required by the `disturbanceParameters` ",
                       "object and the disturbanceList containing current disturbances ",
                       "and potential disturbances (i.e., for disturbances of Generating type)."),
  keywords = "",
  authors = structure(list(list(given = "Tati", 
                                family = "Micheletti", role = c("aut", "cre"), 
                                email = "tati.micheletti@gmail.com", 
                                comment = NULL)), 
                      class = "person"),
  childModules = character(0),
  version = list(anthroDisturbance_Generator = "1.1.0"),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.md", "anthroDisturbance_Generator.Rmd"), ## same file
  reqdPkgs = list("SpaDES.core (>= 2.1.5.9003)", "ggplot2", "googledrive",
                  "data.table", "PredictiveEcology/reproducible",
                  "raster", "terra", "crayon", "msm", "sf", "pik-piam/rmndt",
                  "fasterize", "stars", "nngeo", "tictoc", "roads", "spaths", "truncnorm",
                  "foreach", "doParallel", "digest"),
  parameters = rbind(
    defineParameter(".plots", "character", "screen", NA, NA,
                    "Used by Plots function, which can be optionally used here"),
    defineParameter(".plotInitialTime", "numeric", start(sim), NA, NA,
                    "Describes the simulation time at which the first plot event should occur."),
    defineParameter(".plotInterval", "numeric", NA, NA, NA,
                    "Describes the simulation time interval between plot events."),
    defineParameter(".saveInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first save event should occur."),
    defineParameter(".saveInterval", "numeric", NA, NA, NA,
                    "This describes the simulation time interval between save events."),
    defineParameter(".seed", "list", list(), NA, NA,
                    "Named list of seeds to use for each event (names)."),
    defineParameter(".useCache", "logical", FALSE, NA, NA,
                    "Should caching of events or module be used?"),
    defineParameter("runInterval", "numeric", 10, NA, NA,
                    paste0("Should the module be run every decade? This speeds up module testing as ",
                           "testing if the events need to be run at every time is time-consuming. If ",
                           "the user knows the disturbances happen every X years, X can be passed here.")),
    defineParameter("saveInitialDisturbances", "logical", TRUE, NA, NA,
                    paste0("Should the disturbance rasters be saved at each step? These are saved ",
                           "to Paths[['outputPath']] as a RasterLayer, with disturbanceLayer as prefix",
                           "the name of the industry and the year as suffix.",
                           "If TRUE, it saves the initial conditions (IC)")),
    defineParameter("generatedDisturbanceAsRaster", "logical", FALSE, NA, NA,
                    paste0("Should the new disturbances generated be in raster format? This has ",
                           "potential downsides regarding size of disturbances generated (i.e., minimum",
                           " size possible is the resolution of raster)")),
    defineParameter("checkDisturbancesForBuffer", "logical", FALSE, NA, NA,
                    paste0("Should the module check the recently generated disturbances? This means ",
                           "that the module will buffer the recently disturbed layer and compare it ",
                           "to the previous layer, outputting a message indicating how much of the total",
                           " area this represents. Note that no objects are created, just the message ",
                           "is outputted.")),
    defineParameter("disturbFirstYear", "logical", FALSE, NA, NA,
                    paste0("Should disturbances be generated already in the initial year? Normally, ",
                           "we would save the initial disturbances (i.e., 2011) as they are coming from ",
                           "data, and only start generating disturbances once we don't have the data",
                           "(i.e., post-2015). So this defaults to FALSE.",
                           "If TRUE, it will already generate disturbances in start(sim)")),
    defineParameter("saveCurrentDisturbances", "logical", TRUE, NA, NA,
                    paste0("Should the disturbance rasters be saved at each step? These are saved ",
                           "to Paths[['outputPath']] as a RasterLayer, with disturbanceLayer as prefix",
                           "the name of the industry and the year as suffix.",
                           "If TRUE, it saves at the end of each step.")),
    defineParameter("disturbanceRateRelatesToBufferedArea", "logical", TRUE, NA, NA,
                    paste0("Is the DisturbanceRate a % of already buffered (to 500m) disturbance?",
                           " This is normally what is used for caribou.")),
    defineParameter("growthStepEnlargingPolys", "numeric", 1, NA, NA,
                    paste0("Growth step used for iteratively achieving the total area growth of ",
                           "new disturbances type Enlarging for polygons. If the iterations take too",
                           " long, one should increase this number. If the summarized value is too",
                           " far from 0, one should decrease this number.")),
    defineParameter("growthStepGenerating", "numeric", 0.5, NA, NA,
                    paste0("Increasing factor to speed up total area of ",
                           "new disturbances type Generating. If the iterations take too",
                           " long, one should increase this number. If the summarized value is too",
                           " far from 0, one should decrease this number.",
                           " Not used if disturbanceRateRelatesToBufferedArea == TRUE")),
    defineParameter("growthStepEnlargingLines", "numeric", 1, NA, NA,
                    paste0("Growth step used for iteratively achieving the total area growth of ",
                           "new disturbances type Enlarging for lines. If the iterations take too",
                           " long, one should increase this number. If the summarized value is too",
                           " far from 0, one should decrease this number.")),
    defineParameter("connectingBlockSize", "numeric", NULL, NA, NA,
                    paste0("connectingBlockSize defaults to NULL. It is used to connecting layers ",
                           "after generation. Applying blocking technique speeds up disturbance.",
                           " If too high, many lines might connect from the same place. Decreasing ",
                           " the parameter connectingBlockSize or setting it to NULL, will improve")),
    defineParameter(".runName", "character", "run1", NA, NA,
                    paste0("If you would like your simulations' results to have an appended name ",
                           "(i.e., replicate number, study area, etc) you can use this parameter")),
    defineParameter("seismicLineGrids", "numeric", 500, NA, NA,
                    paste0("How many grids concomitantly should the model produce when creating ",
                           " seismic lines? Defaults to 500. If seismic disturbance is being ",
                           "produced over the expected amount, please provide smaller values.")),
    defineParameter(".inputFolderFireLayer", "character", Paths[["inputPath"]], NA, NA,
                    paste0("If you have the fire (i.e., rstCurrBurn) in a folder that is NOT the ",
                           "inputs folder, you can pass it here")),
    defineParameter("totalDisturbanceRate", "numeric", NULL, NA, NA,
                    paste0("If passed, the module will use ECCC data to calculate the % each ",
                           "disturbance should represent to achieve (as close as possible) ",
                           " the total expected disturbance rate. Mainly used for early in ",
                           "simulations, when value ranges are unknown.")),
    defineParameter("aggregateSameDisturbances", "logical", TRUE, NA, NA,
                    paste0("If TRUE, when using ECCC data to calculate disturbance rates, it aggregates",
                           " the features that have the same class and dissolves their boundaries. ",
                           " This may influence disturbance rate calculations especially if ",
                           "disturbanceRateRelatesToBufferedArea = TRUE (i.e., overlapping disturbances ",
                           "from the same class will be double counted if aggregateSameDisturbances = FALSE) ",
                           "If DisturbanceRate is provided, this parameter is ignored.")),
    defineParameter("maskOutLinesFromPolys", "logical", TRUE, NA, NA,
                    paste0("If TRUE, when using ECCC data to calculate disturbance rates, it masks out",
                           " the lines from polygons when these overlap (i.e., more likely when ",
                           " disturbanceRateRelatesToBufferedArea = TRUE). This may influence ",
                           "disturbance rate calculations as these will be double counted if FALSE).",
                           " If DisturbanceRate is provided, this parameter is ignored.")),
    defineParameter("useRoadsPackage", "logical", FALSE, NA, NA,
                    paste0("If TRUE, uses the roads package to connect all disturbances.",
                           " It is very slow when area is bigger and does NOT work with ",
                           " generatedDisturbanceAsRaster = TRUE nor connectingBlockSize != NULL).")),
    defineParameter("siteSelectionAsDistributing", "character", "seismicLines", NA, NA,
                    paste0("Informs which disturbance should NOT be of type 'exhausting': exhausts ",
                           "the area available for new disturbances sequentially, from the most to ",
                           "the least likely. Provided classes will be used with 'distributing' ",
                           "to probabilistically select which polygon ",
                           " (i.e., area) the provided disturbance will fall within.",
                           "There is speed tradeoff in using 'exhausting', ",
                           "and 'disturbing'. While distributing is more accurate, exhausting is ",
                           " likely a good option for uncommon (i.e., windpower), or specific ",
                           "(i.e., forestry, mining, oil facilities) disturbances, which likely won't ",
                           "cover the whole extent of the area. 'distributing' is slower but might be more",
                           "realistic for disturbances which have the potential of overtaking an area ",
                           "(i.e., seismic lines). Defaults to NA but can take any of the ",
                           "disturbanceOrigin from the input disturbanceParameters (i.e., oilGas,",
                           "mining, cutblocks, windTurbines, seismicLines)")),
    defineParameter("probabilityDisturbance", "list", NULL, NA, NA,
                    paste0("Informs to disturbances passed on siteSelectionAsDistributing ",
                           "the probability of each specific polygon being chosen. ",
                           "If passed, needs to be a list 2-column data.table with names 'Potential'",
                           "and 'probPoly' with Potential matching disturbance ORIGIN from ",
                           "disturbanceParameters and probPoly matching the probabilities for each ",
                           "polygon (generally higher values are more likely to have disturbances ",
                           "happening). Defaults to NULL, which is time consuming, but calculates ",
                           "it automatically from data.")),
    defineParameter("maskWaterAndMountainsFromLines", "logical", TRUE, NA, NA,
                    paste0("If TRUE, masks out steep mountain tops and water (i.e., lakes and rivers)",
                           "from map, so linear features (i.e., transmission lines and roads) don't",
                           "cross these")),
    defineParameter("altitudeCut", "numeric", 550, NA, NA,
                    paste0("If TRUE, max altitude (in meters) to mask mountain tops",
                           "from map, so linear features (i.e., transmission lines and roads) don't",
                           "cross these",
                           "Only used if maskWaterAndMountainsFromLines == TRUE")),
    defineParameter("clusterDistance", "numeric", 1000, NA, NA,
                    paste0("Used for grouping seismic lines to identify grid characteristics ",
                           "(i.e., lines length, distances, number of lines)",
                           "Increasing this number likely speeds up the simulation, but ",
                           "may have some compromising with accuracy. ",
                           "Reducing the number also makes seismic lines closer to each other",
                           "Only used if useClusterMethod = TRUE")),
    defineParameter("distanceNewLinesFactor", "numeric", 1.5, NA, NA,
                    paste0("Used for getting distance threshold for new lines from a center point.",
                           "The higher, the more distant the lines are allowed to be. It is a ",
                           "factor of clusterDistance",
                           "(i.e., clusterDistance * distanceNewLinesFactor = max distance)",
                           "Reducing the number also makes seismic lines closer to each other",
                           "Only used if useClusterMethod = TRUE")),
    defineParameter("useClusterMethod", "logical", TRUE, NA, NA,
                    paste0("If want to use clusters to identify seismic lines grouping, TRUE.",
                           "This alternative generates lines more similar to satellite data, ",
                           "although attention needs to be paid to the fact that satellite data ",
                           "for seismic lines is flawed (i.e., misses a lot of lines due to ",
                           "resolution)")),
    defineParameter("runClusteringInParallel", "logical", FALSE, NA, NA,
                    paste0("If TRUE, runs clusters' analysis in parallel (within the most internal ",
                           "for loop). This may be slower depending on amount of data")),
    defineParameter("refinedStructure", "logical", FALSE, NA, NA,
                    paste0("If TRUE, it tries to copy the structure of the line clusters ",
                           "for seismic lines (if useClusterMethod = TRUE). While this slows down ",
                           "runtime, the final linear structure is generated very similarly (but",
                           "with randomness to the structure of original lines in terms of number ",
                           "of parallel and perpendicular lines.")),
    defineParameter(name = "diffYears", class = "character", default = "2010_2015", NA, NA,
                    paste0("Suffix indicating the years compared for the",
                           "difference calculation of disturbances rate. Needs to be ",
                           "in the format OLDYEAR_NEWYEAR")),
    defineParameter("archiveNEW", "character", paste0("ECCC_2015_anthro_dist_corrected_to_NT1_2016",
                                                      "_final.zip"), NA, NA,
                    "Filename of the newer archive dataset (zip file)."),
    defineParameter("targetFileNEW", "character",
                    c("BEADlines2015_NWT_corrected_to_NT1_2016.shp",
                      "BEADpolys2015_NWT_corrected_to_NT1_2016.shp"), NA, NA,
                    "Vector of target filenames within the newer archive to be extracted."),
    defineParameter("urlNEW", "character",
                    paste0("https://drive.google.com/file/d/",
                           "1sxAa0wwwt7iwiHD7zB0DDnjfqyIQjKI2"), NA, NA,
                    "URL to download the newer dataset archive."),
    defineParameter("archiveOLD", "character",
                    paste0("Boreal-ecosystem-anthropogenic-disturbance-vector-data-",
                           "2008-2010.zip"), NA, NA,
                    "Filename of the older archive dataset (zip file)."),
    defineParameter("targetFileOLD", "character",
                    c("EC_borealdisturbance_linear_2008_2010_FINAL_ALBERS.shp",
                      "EC_borealdisturbance_polygonal_2008_2010_FINAL_ALBERS.shp"), NA, NA,
                    "Vector of target filenames within the older archive to be extracted."),
    defineParameter("urlOLD", "character",
                    paste0("https://www.ec.gc.ca/data_donnees/STB-DGST/003/",
                           "Boreal-ecosystem-anthropogenic-disturbance-vector-data-",
                           "2008-OLD.zip"), NA, NA,
                    "URL to download the older dataset archive.")
  ),
  inputObjects = bindrows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput(objectName = "disturbanceList", objectClass = "list",
                 desc = paste0("List (general category) of lists (specific ",
                               "class) needed for generating ",
                               "disturbances. This is generally the output from a potential",
                               "Resources module (i.e., potentialResourcesNT_DataPrep), ",
                               "where multiple potential layers (i.e., mining",
                               " and oilGas) we replaced by only one layer with the highest",
                               "values being the ones that need to be filled ",
                               "with new developments first, or prepared potential layers",
                               " (i.e., potentialCutblocks)."),
                 sourceURL = "https://drive.google.com/file/d/1v7MpENdhspkWxHPZMlmx9UPCGFYGbbYm/view?usp=sharing"),
    
    expectsInput(objectName = "disturbanceParameters", objectClass = "data.table",
                 desc = paste0("Table with the following columns: ",
                               
                               "dataName --> this column groups the type of data ",
                               "by sector (i.e., Energy, Settlements, OilGas, ",
                               "Mining, Forestry, Roads)",
                               
                               "dataClass --> this column details the type of data ",
                               "ALWAYS with 'potential' starting (i.e., potentialSettlements ",
                               "potentialWindTurbines, potentialCutblocks, etc.)",
                               "can harmonize different ones. Potential data classes ",
                               "can be of three general disturbanceType (see below)",
                               
                               "disturbanceType --> Potential data classes ",
                               "can be of three general types:",
                               "1. Enlarging (i.e., potentialSettlements",
                               " and potentialSeismicLines): where the potential one is ",
                               "exactly the same as the current layer, and we",
                               " only buffer it with time",
                               "2. Generating (i.e., potentialWindTurbines, potentialOilGas",
                               "potentialMineral, potentialForestry): where the ",
                               "potential layers are only the potential where ",
                               "structures can appear based on a specific rate",
                               "3. Connecting (i.e., potentialPipelines, ",
                               "potentialTransmission, potentialRoads incl. ",
                               "forestry ones): where the potential layer needs ",
                               "to have the current/latest transmission, pipeline,",
                               " and road network. This process will depend on ",
                               "what is generated in point 2.",
                               
                               "disturbanceRate --> what is the rate of generation for ",
                               "disturbances PER YEAR in % of type Enlarging and Generating. For ",
                               "disturbances type Connecting, disturbanceRate is NA. ",
                               "If not specified when needed, the module will try to derive ",
                               "it from data.",
                               
                               "disturbanceSize --> if there is a specific size the disturbance in m2 ",
                               "type Generating should have, it is specified here. If not specified, ",
                               " the module will try to derive it from data. For disturbances ",
                               "type Enlarging anb Connecting, disturbanceSize is NA.",
                               "If not specified when needed, the module will try to derive ",
                               "it from data.",
                               
                               "disturbanceOrigin --> dataClass that should be used as the 'original' ",
                               "to be either modified (i.e., Enlarging, Generating) or as origin  ",
                               "point for Connecting types.",
                               
                               "disturbanceEnd --> end points for Connecting layers (i.e., ",
                               "newly created windTurbines: connect into powerLines, ",
                               "newly created windTurbines: connect into roads, ",
                               "newly created oilGas: connect into pipeline, ",
                               "newly created oilGas: connect into roads, ",
                               "newly created settlements: connect into roads, ",
                               "newly created mines: connect into roads",
                               "newly created cutblocks: connect into roads)",
                               
                               "disturbanceInterval --> interval for which ",
                               "this disturbance should happen ",
                               
                               "resolutionVector --> original resolution ",
                               "of the data that generated this vector ",
                               
                               "It defaults to an example in the Northwest ",
                               "Territories and needs to be provided if the ",
                               "study area is not in this region (i.e., union ",
                               "of BCR6 and NT1)"),
                 sourceURL = "https://drive.google.com/file/d/1Y7_3qjq8VQ1xPdii5RMCDp2RxgQ1E-4T/view?usp=sharing"),
    expectsInput(objectName = "disturbanceDT", objectClass = "data.table", 
                 desc = paste0("This data.table needs to contain the following",
                               " columns: ",
                               
                               "dataName --> this column groups the type of data ",
                               "by sector (i.e., Energy, Settlements, OilGas, ",
                               "Mining, Forestry, Roads)",
                               
                               "URL --> URL link for the specific dataset",
                               
                               "classToSearch --> exact polygon type/class to ",
                               "search for when picking from a dataset with ",
                               "multiple types. If this is not used (i.e., your",
                               " shapefile is alreday all the data needed), you ",
                               "should still specify this so each entry has a ",
                               "different name",
                               
                               "fieldToSearch --> where should classToSearch be ",
                               "found? If this is specified, then the function ",
                               "will subset the spatial object (most likely a ",
                               "shapefile) to classToSearch. Only provide this ",
                               "if this is necessary!",
                               
                               "dataClass --> this column details the type of data ",
                               "further (i.e., Settlements, potentialSettlements ",
                               "otherPolygons, otherLines, windTurbines, potentialWindTurbines, ",
                               "hydroStations, oilFacilities, pipelines, etc). ",
                               "Common class to rename the dataset to, so we ",
                               "can harmonize different ones. Potential data classes ",
                               "can be of three general types (that will be ",
                               "specified in the disturbanceGenerator module as ",
                               "a parameter -- ALWAYS with 'potential' starting): ",
                               "1. Enlarging (i.e., potentialSettlements",
                               " and potentialSeismicLines): where the potential one is ",
                               "exactly the same as the current layer, and we",
                               " only buffer it with time",
                               "2. Generating (i.e., potentialWind, potentialOilGas",
                               "potentialMineral, potentialForestry): where the ",
                               "potential layers are only the potential where ",
                               "structures can appear based on a specific rate",
                               "3. Connecting (i.e., potentialPipelines, ",
                               "potentialRoads incl. ",
                               "forestry ones): where the potential layer needs ",
                               "to have the current/latest transmission, pipeline,",
                               " and road network. This process will depend on ",
                               "what is generated in point 2.",
                               
                               "fileName --> If the original file is a .zip and ",
                               "the features are stored in one of more shapefiles",
                               " inside the .zip, please provide which shapefile ",
                               " to be used",
                               
                               "dataType --> please provide the data type of the ",
                               "layer to be used. These are the current accepted ",
                               " formats: 'shapefile' (.shp or .gdb), 'raster' ",
                               "(.tif, which will be converted into shapefile), ",
                               "and 'mif' (which will be read as a shapefile).",
                               
                               "It defaults to an example in the Northwest ",
                               "Territories and needs to be provided if the ",
                               "study area is not in this region (i.e., union ",
                               "of BCR6 and NT1)"),
                 sourceURL = "https://drive.google.com/file/d/1wHIz_G088T66ygLK9i89NJGuwO3f6oIu/view?usp=sharing"),
    expectsInput(objectName = "studyArea", 
                 objectClass = "SpatialPolygonDataFrame|spatVector", 
                 desc = paste0("Study area to which the module should be ",
                               "constrained to. Defaults to NT1+BCR6. Object ",
                               "can be of class 'vect' from terra package"), 
                 sourceURL = "https://drive.google.com/file/d/1RPfDeHujm-rUHGjmVs6oYjLKOKDF0x09/view?usp=sharing"),
    expectsInput(objectName = "rasterToMatch", 
                 objectClass = "RasterLayer|spatRaster", 
                 desc = paste0("All spatial outputs will be reprojected and ",
                               "resampled to it. Defaults to NT1+BCR6. Object ",
                               "can be of class 'rast' from terra package"), 
                 sourceURL = "https://drive.google.com/file/d/11yCDc2_Wia2iw_kz0f0jOXrLpL8of2oM/view?usp=sharing"),
    expectsInput(objectName = "rstCurrentBurn", 
                 objectClass = "RasterLayer", 
                 desc = paste0("A binary raster with 1 values representing burned pixels. ",
                               "This raster is normally produced by either the module historicFires or ",
                               "a fire simulation module (i.e., fireSense, SCFM, LandMine)"),
                 sourceURL = NA),
    expectsInput(objectName = "DisturbanceRate", 
                 objectClass = "data.table", 
                 desc = paste0("Rate of change (disturbance) increase over the study area per year. ",
                               "Defaults to calculating the disturbance (ECCC data) over the entire area per year,",
                               " if totalDisturbanceRate is not provided. Needs to have:",
                               "dataName: settlements, oilGas, oilGas, mining, forestry, Energy",
                               "dataClass: potentialSettlements, potentialSeismicLines, potentialOilGas,",
                               "potentialMining, potentialCutblocks, potentialWindTurbines",
                               "disturbanceType: Enlarging or Generating (see disturbanceDT object for details)",
                               "disturbanceOrigin: settlements, seismicLines, oilGas, mining, cutblocks, windTurbines",
                               "disturbanceRate: representing a % of the study area to be newly disturbed per year"),
                 sourceURL = NA),
    expectsInput(objectName = "DEM", 
                 objectClass = "spatRaster", 
                 desc = paste0("Elevation map of the study area. If not provided, it uses as default ",
                               "the DEM (`elavation_30()`) from the geodata R package."),
                 sourceURL = NA), 
    expectsInput(objectName = "featuresToAvoid", 
                 objectClass = "spatRaster", 
                 desc = paste0("Raster map of the study area with areas to avoid (i.e., water, wetlands, mountain",
                               "tops) for linear feature building (excluding seismic lines). ",
                               "If not provided, it uses as default data from the geodata R package. ", 
                               "Only used if maskWaterAndMountainsFromLines == TRUE"),
                 sourceURL = NA)
  ),
  outputObjects = bindrows(
    createsOutput(objectName = "disturbanceList", objectClass = NA, 
                  desc = paste0("Updated list (general category) of lists (specific ",
                                "class) of disturbances and the potential needed for ",
                                "generating disturbances. ")),
    createsOutput(objectName = "currentDisturbanceLayer", objectClass = "list", 
                  desc = paste0("List (per year) of rasters with all current disturbances.",
                                "Can be used  for other purposes but was created to filter potential",
                                " pixels that already have disturbances to avoid choosing new ",
                                "pixels in existing disturbed ones"))
  )
))

## event types
#   - type `init` is required for initialization

doEvent.anthroDisturbance_Generator = function(sim, eventTime, eventType) {
  switch(
    eventType,
    init = {
      # Make sure siteSelectionAsDistributing is either 
      if (!P(sim)$siteSelectionAsDistributing %in% c(NA, unique(sim$disturbanceParameters$disturbanceOrigin)))
        stop(paste0("Only disturbances provided in disturbanceOrigin column of object ",
                    "disturbanceParameters are accepted for parameter siteSelectionAsDistributing. ",
                    "Please provide NA or any combination of the following: ", 
                    paste(unique(sim$disturbanceParameters$disturbanceOrigin), collapse = ", ")
        ))
      
      # Make sure RTM and studyArea projections match
      sim$studyArea <- projectInputs(sim$studyArea, 
                                     targetCRS = crs(sim$rasterToMatch))
      
      ### Make sure that disturbanceDT is data.table      
      if (any(class(sim$disturbanceDT) != "data.table")){
        tryCatch({
          sim$disturbanceDT <- as.data.table(sim$disturbanceDT)
        }, error = function(e){
          warning(paste0("disturbanceDT was provided with class ",
                         class(sim$disturbanceDT), " and conversion to ",
                         "data.table failed. Please provide this object as a ",
                         "data.table"), immediate. = TRUE)
          stop(e)
        })
      }
      
      sim$currentDisturbanceLayer <- list()
      
      ### Make sure that growthStepEnlargingLines and growthStepEnlargingPolys are > 0
      
      if (P(sim)$growthStepEnlargingLines <= 0){
        warning(paste0("growthStepEnlargingLines needs to be > 1 but is currently set to ", 
                       P(sim)$growthStepEnlargingLines, ". Overriding it to 1"), immediate. = TRUE)
        P(sim)$growthStepEnlargingLines <- 1
      }
      
      if (P(sim)$growthStepEnlargingPolys <= 0){
        warning(paste0("growthStepEnlargingLines needs to be > 1 but is currently set to ", 
                       P(sim)$growthStepEnlargingPolys, ". Overriding it to 1"), immediate. = TRUE)
        P(sim)$growthStepEnlargingPolys <- 1
      }
      
      # Make sure the parameter diffYears has the correct format
      parts <- strsplit(P(sim)$diffYears, "_")[[1]] # [[1]] extracts the vector
      # Initialize difference variable
      year_difference <- NA
      is_valid <- FALSE
      
      # Check if we got exactly two parts
      if (length(parts) == 2) {
        # 2. Try to convert parts to numeric
        # Suppress warnings in case conversion fails (we handle NAs explicitly)
        num1 <- suppressWarnings(as.numeric(parts[1]))
        num2 <- suppressWarnings(as.numeric(parts[2]))
        # 3. Validate: Check if both parts are numbers and num1 < num2
        if (!is.na(num1) && !is.na(num2)) { # Check if both are valid numbers
          if (num1 < num2) { # Check if the first is smaller than the second
            is_valid <- TRUE
        } else {
            stop("Validation failed: First year (", num1, ") is not smaller than the second year (", num2, ").\n", sep="")
          }
        } else {
          stop("Validation failed: One or both parts ('", parts[1], "', '", parts[2], "') are not valid numbers.\n", sep="")
        }
      } else {
        stop("Validation failed: String '", diffYears, "' does not contain exactly two years separated by '_' such as '2010_2015'.\n", sep="")
      }
      
      # schedule future event(s)
      sim <- scheduleEvent(sim, time(sim), "anthroDisturbance_Generator", "calculatingSize", eventPriority = 4)
      sim <- scheduleEvent(sim, time(sim), "anthroDisturbance_Generator", "calculatingRate", eventPriority = 4)
      sim <- scheduleEvent(sim, time(sim), "anthroDisturbance_Generator", "generatingDisturbances", eventPriority = 4)
      sim <- scheduleEvent(sim, time(sim), "anthroDisturbance_Generator", "updatingDisturbanceList", eventPriority = 4)
    },
    calculatingSize = {

      # Check for needed sizes. If all provided, skip event
      mod$.whichNeedSize <- which(sim$disturbanceParameters[, disturbanceType == "Generating" &
                                                              is.na(disturbanceSize)])
      if (length(mod$.whichNeedSize) != 0)
        sim$disturbanceParameters <- calculateSize(disturbanceParameters = sim$disturbanceParameters,
                                                   whichToUpdate = mod$.whichNeedSize,
                                                   disturbanceList = sim$disturbanceList)
    },
    calculatingRate = {
      # Check for needed rates. If all provided, skip event
      mod$.whichNeedRates <- which(sim$disturbanceParameters[, disturbanceType %in% c("Generating", "Enlarging") &
                                                               is.na(disturbanceRate)])
      if (length(mod$.whichNeedRates) != 0)
        sim$disturbanceParameters <- calculateRate(disturbanceParameters = sim$disturbanceParameters,
                                                   whichToUpdate = mod$.whichNeedRates,
                                                   studyArea = sim$studyArea,
                                                   disturbanceList = sim$disturbanceList,
                                                   RTM = sim$rasterToMatch,
                                                   disturbanceDT = sim$disturbanceDT,
                                                   destinationPath = Paths[["inputPath"]],
                                                   totalDisturbanceRate = P(sim)$totalDisturbanceRate,
                                                   DisturbanceRate = sim$DisturbanceRate,
                                                   disturbanceRateRelatesToBufferedArea = P(sim)$disturbanceRateRelatesToBufferedArea,
                                                   maskOutLinesFromPolys = P(sim)$maskOutLinesFromPolys,
                                                   aggregateSameDisturbances = P(sim)$aggregateSameDisturbances,
                                                   diffYears = P(sim)$diffYears,
                                                   archiveNEW = P(sim)$archiveNEW,
                                                   targetFileNEW = P(sim)$targetFileNEW,
                                                   urlNEW = P(sim)$urlNEW,
                                                   archiveOLD = P(sim)$archiveOLD,
                                                   targetFileOLD = P(sim)$targetFileOLD,
                                                   urlOLD = P(sim)$urlOLD
                                                   )
    },
    generatingDisturbances = {
      
      if (all(P(sim)$saveInitialDisturbances,
              start(sim) == time(sim))){
        message(crayon::yellow(paste0("The parameter saveInitialDisturbances is TRUE.",
                                      " Saving initial disturbance layers")))
        saveDisturbances(disturbanceList = sim$disturbanceList,
                         currentTime = "IC", 
                         overwrite = TRUE,
                         runName = P(sim)$.runName)
        
        initialBufferedAnthropogenicDisturbance500m <- createBufferedDisturbances(disturbanceList = sim$disturbanceList,
                                                                                  bufferSize = 500,
                                                                                  rasterToMatch = sim$rasterToMatch,
                                                                                  studyArea = sim$studyArea,
                                                                                  currentTime = "IC",
                                                                                  convertToRaster = TRUE)
        anthroDistFilePath <- file.path(Paths[["outputPath"]],
                                        paste0("bufferedAnthDist_500m_", 
                                               time(sim), ".tif"))
        
        message(paste0("Writing buffered disturbance layer for ", time(sim)))
        terra::writeRaster(initialBufferedAnthropogenicDisturbance500m, 
                           filename = anthroDistFilePath,
                           overwrite = TRUE)
      }
      
      # Check if the time(sim) is within the interval to run the disturbances
      mod$.whichToRun <- if (all(!P(sim)$disturbFirstYear,
                                 time(sim) == start(sim))){
        mod$.firstYear <- NA
        NULL
      } else {
        if (is.na(mod$.firstYear)){
          mod$.firstYear <- TRUE 
          message(paste0("First year of running disturbances: ", time(sim)))
        } else {
          mod$.firstYear <- FALSE
        }
        whichDisturbancesToGenerate(startTime = start(sim),
                                    currentTime = time(sim),
                                    endTime = end(sim),
                                    disturbanceParameters = sim$disturbanceParameters)
      }
      if (length(mod$.whichToRun) != 0){ # If anything is scheduled
        forestryScheduled <- "forestry" %in% sim$disturbanceParameters[mod$.whichToRun, dataName]
        if (forestryScheduled) { # forestry scheduled?
          if (is.null(sim$rstCurrentBurn)){
            # Try to get rstCurrentBurn if no module is producing it!
            mod$rstCurrentBurn <- createModObject(data = "rstCurrentBurn", 
                                                  sim = sim, 
                                                  pathInput = P(sim)$.inputFolderFireLayer, 
                                                  currentTime = time(sim),
                                                  returnNULL = TRUE,
                                                  fun = raster::raster)
            if (!is.null(mod$rstCurrentBurn))
              message(crayon::green("Fire layer found in inputs folder! Using it for the simulation."))
          } else {
            mod$rstCurrentBurn <- sim$rstCurrentBurn
          }
        }
        currDis <- tryCatch({
          tail(sim$currentDisturbanceLayer,
               n = 1)[[1]]
        }, error = function(e){
          return(NULL) 
        })
        if (P(sim)$generatedDisturbanceAsRaster){
          mod$updatedLayers <- generateDisturbances(disturbanceParameters = sim$disturbanceParameters,
                                                    disturbanceList = sim$disturbanceList,
                                                    currentTime = time(sim),
                                                    studyArea = sim$studyArea,
                                                    rasterToMatch = sim$rasterToMatch,
                                                    fires = mod$rstCurrentBurn,
                                                    currentDisturbanceLayer = currDis,
                                                    disturbanceRateRelatesToBufferedArea = P(sim)$disturbanceRateRelatesToBufferedArea,
                                                    growthStepEnlargingPolys = P(sim)$growthStepEnlargingPolys,
                                                    growthStepEnlargingLines = P(sim)$growthStepEnlargingLines,
                                                    growthStepGenerating = P(sim)$growthStepGenerating,
                                                    connectingBlockSize = P(sim)$connectingBlockSize,
                                                    outputsFolder = Paths[["outputPath"]],
                                                    runName = P(sim)$.runName,
                                                    checkDisturbancesForBuffer = P(sim)$checkDisturbancesForBuffer)
        } else {
          mod$updatedLayers <- generateDisturbancesShp(disturbanceParameters = sim$disturbanceParameters,
                                                       disturbanceList = sim$disturbanceList,
                                                       currentTime = time(sim),
                                                       studyArea = sim$studyArea,
                                                       firstTime = mod$.firstYear,
                                                       rasterToMatch = sim$rasterToMatch,
                                                       fires = mod$rstCurrentBurn,
                                                       currentDisturbanceLayer = currDis,
                                                       siteSelectionAsDistributing = P(sim)$siteSelectionAsDistributing,
                                                       seismicLineGrids = P(sim)$seismicLineGrids,
                                                       disturbanceRateRelatesToBufferedArea = P(sim)$disturbanceRateRelatesToBufferedArea,
                                                       growthStepEnlargingPolys = P(sim)$growthStepEnlargingPolys,
                                                       growthStepEnlargingLines = P(sim)$growthStepEnlargingLines,
                                                       growthStepGenerating = P(sim)$growthStepGenerating,
                                                       connectingBlockSize = P(sim)$connectingBlockSize,
                                                       outputsFolder = Paths[["outputPath"]],
                                                       runName = P(sim)$.runName,
                                                       checkDisturbancesForBuffer = P(sim)$checkDisturbancesForBuffer,
                                                       useRoadsPackage = P(sim)$useRoadsPackage,
                                                       probabilityDisturbance = P(sim)$probabilityDisturbance,
                                                       maskWaterAndMountainsFromLines = P(sim)$maskWaterAndMountainsFromLines,
                                                       featuresToAvoid = sim$featuresToAvoid,
                                                       altitudeCut = P(sim)$altitudeCut,
                                                       clusterDistance = P(sim)$clusterDistance,
                                                       distanceNewLinesFactor = P(sim)$distanceNewLinesFactor,
                                                       useClusterMethod = P(sim)$useClusterMethod,
                                                       runClusteringInParallel = P(sim)$runClusteringInParallel,
                                                       refinedStructure = P(sim)$refinedStructure)
        }
        sim$currentDisturbanceLayer[[paste0("Year", time(sim))]] <- mod$updatedLayers$currentDisturbanceLayer
      } else {
        message("No disturbances scheduled for this year")
      }
      sim <- scheduleEvent(sim, time(sim) + P(sim)$runInterval, "anthroDisturbance_Generator", "generatingDisturbances")
    },
    updatingDisturbanceList = {
      if (length(mod$.whichToRun) != 0){
        sim$disturbanceList <- replaceListFast(disturbanceList = sim$disturbanceList,
                                               updatedLayersAll = mod$updatedLayers,
                                               currentTime = time(sim),
                                               disturbanceParameters = sim$disturbanceParameters)
        
        if (P(sim)$saveCurrentDisturbances){
          message(paste0("Saving current disturbances for year ", time(sim)))
          saveDisturbances(disturbanceList = sim$disturbanceList,
                           currentTime = time(sim), 
                           overwrite = TRUE,
                           runName = P(sim)$.runName)
        }
      }
      sim <- scheduleEvent(sim, time(sim) + P(sim)$runInterval, "anthroDisturbance_Generator", "updatingDisturbanceList")
      
    },
    warning(paste("Undefined event type: \'", current(sim)[1, "eventType", with = FALSE],
                  "\' in module \'", current(sim)[1, "moduleName", with = FALSE], "\'", sep = ""))
  )
  return(invisible(sim))
}

.inputObjects <- function(sim) {
  dPath <- dataPath(sim)
  message(currentModule(sim), ": using dataPath '", dPath, "'.")
  if (!suppliedElsewhere(object = "studyArea", sim = sim)) {
    sim$studyArea <- prepInputs(url = extractURL("studyArea"),
                                targetFile = "NT1_BCR6.shp",
                                alsoExtract = "similar",
                                destinationPath = dPath)
    
    message(crayon::red(paste0("studyArea was not supplied. Defaulting to BCR6+NT1 in the",
                               " Northwest Territories")))
  }
  
  if (!suppliedElsewhere(object = "rasterToMatch", sim = sim)) {
    sim$rasterToMatch <- prepInputs(url = extractURL("rasterToMatch"),
                                    targetFile = "RTM.tif",
                                    destinationPath = dPath)
    
    message(crayon::red(paste0("rasterToMatch was not supplied. Defaulting to BCR6+NT1 in the",
                               " Northwest Territories")))
  }
  
  if (!suppliedElsewhere(object = "disturbanceList", sim = sim)) {
    sim$disturbanceList <- unwrapTerraList(terraList = extractURL("disturbanceList"), 
                                           generalPath = dataPath(sim))
    
    message(crayon::red(paste0("disturbanceList was not supplied. The current should only ",
                               " be used for module testing purposes ! Please run the module(s) ",
                               "`anthroDisturbance_DataPrep` and `potentialResourcesNT_DataPrep`")))
  }
  
  if (!suppliedElsewhere(object = "disturbanceParameters", sim = sim)) {
    sim$disturbanceParameters <- data.table(dget(file = paste0("https://raw.githubusercontent.com",
                                                               "/tati-micheletti/anthroDisturbance_Generator",
                                                               "/refs/heads/main/data/paramsGeneral.txt")))
    # Example Disturbance Parameters for the whole NT1
    # sim$disturbanceParameters <- prepInputs(url = extractURL("disturbanceParameters"),
    #                                         targetFile = "disturbanceParameters.csv",
    #                                         destinationPath = dPath,
    #                                         fun = "data.table::fread",
    #                                         header = TRUE,
    #                                         userTags = "disturbanceParameters")
    
    message(crayon::red(paste0("disturbanceParameters was not supplied. Defaulting to an example from ",
                               " Northwest Territories")))
  }
  
  if (!suppliedElsewhere(object = "rstCurrentBurn", sim = sim)) {
    
    message(crayon::red(paste0("rstCurrentBurn was not supplied and is not being generated. ",
                               "The module will try to recover it from the inputs folder. ",
                               " If this fails, the forestry activities will be considered ",
                               "without a fire regime!")))
  }
  
  if (!suppliedElsewhere(object = "disturbanceDT", sim = sim)) {
    sim$disturbanceDT <- prepInputs(url = extractURL("disturbanceDT"),
                                    targetFile = "disturbanceDT.csv",
                                    destinationPath = dPath,
                                    fun = "data.table::fread",
                                    header = TRUE,
                                    userTags = "disturbanceDT")
    
    warning(paste0("disturbanceDT was not supplied. Defaulting to an example from ",
                   " Northwest Territories"), immediate. = TRUE)
  }
  
  if (!suppliedElsewhere(object = "DisturbanceRate", sim = sim)){
    sim$DisturbanceRate <- NULL
    warning(paste0("The table DisturbanceRate was not supplied. The module will use ECCC data to",
                   "calculate disturbance rates.",
                   "If other rates are desired, please provide DisturbanceRate"), 
            immediate. = TRUE)
  }
  
  if (P(sim)$useRoadsPackage){
    if (!suppliedElsewhere(object = "DEM", sim = sim)){
      sim$DEM <- NULL
      warning(paste0("The package 'roads' requires a DEM for the study area. ",
                     "This was not supplied but the module will try to generate one ",
                     "using the information about the study area and the package `geodata`"), 
              immediate. = TRUE)
    }
  }
  if (P(sim)$maskWaterAndMountainsFromLines){
    if (!suppliedElsewhere(object = "featuresToAvoid", sim = sim)){
      sim$featuresToAvoid <- NULL
      warning(paste0("The adjustment to road building (i.e., avoid lakes, wetlands, mountain tops, etc) ",
                     "requires a layer for the study area. ",
                     "This was not supplied but the module will try to generate one encompassing water",
                     " (rivers, lakes and mountain tops) using the information about the study area", 
                     " and the package `geodata`"), 
              immediate. = TRUE)
    }
  }
  return(invisible(sim))
}

